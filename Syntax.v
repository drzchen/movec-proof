Require Import Compare_dec.
Require Import EqNat.

Require Import Types.
Require Import Envs.

(******************************************************************************)
(** *                 Syntax of C fragment                                    *)
(******************************************************************************)
(**
  The section gives the fragment of C used in our proof.
  Commands [c_cmd] consist of empty commands [C_Skip],
  straight-line sequence of commands [C_Seq], assignments [C_Assign],
  function calls [C_Call], and #<i>#free#</i># [C_Free].

  Functions calls declare local variables, but have no arguments or results.
  We also assume that there is a partial map [funTable] from function names or
  addresses to function definitions generated by the compiler. A function
  definition includes a frame which consists of local variables, and a sequence
  of commands.

  Assignments update the memory pointed by left-hand-side [c_lhs] by
  right-hand-side [c_rhs]. The left-hand-side of an assignment is either
  a variable name [C_Var], a pointer dereference [C_Deref], the field of an
  anonymous struct [C_StructPos], or the field of a named struct [C_NamePos].
  The right-hand-side of an assignment can be an integer constant [C_Cons],
  the size of a referent type [C_Size], a function name [C_Fun],
  a left-hand-side [C_Lhs], the address of a left-hand-side [C_Ref],
  the result of a cast [C_Cast], the result of an arithmetic operation [C_Add],
  or the result of #<i>#malloc#</i># [C_Alloc]. We assume that the compiler
  generates some type information which is useful for the proofs. For example,
  we need to know the result type (pointer types) of the address-of and malloc.

  Because the syntax only includes a simple function call that does not have
  inputs and return results, we explicitly define #<i>#malloc#</i># as a
  right-hand-side [C_Alloc], and #<i>#free#</i># as a command [C_Free]. *)

Inductive c_lhs : Set :=
  | C_Var : Var -> c_lhs                    (* vid *)
  | C_Deref : c_lhs -> c_lhs                (* *lhs *)
  | C_StructPos : c_lhs -> c_ident -> c_lhs (* anonymous struct: lhs->id *)
  | C_NamePos : c_lhs -> c_ident -> c_lhs   (* named struct: lhs->id *)
  .

Inductive c_rhs : Set :=
  | C_Const : nat -> c_rhs            (* n *)
  | C_Size : RType -> c_rhs           (* sizeof(r) *)
  | C_Fun : Fun -> c_rhs              (* fid *)
  | C_Lhs : c_lhs -> c_rhs            (* lhs *)
  | C_Ref : AType -> c_lhs -> c_rhs   (* (a* ) &lhs *)
  | C_Cast : AType -> c_rhs -> c_rhs  (* (a) rhs *)
  | C_Add : c_rhs -> c_rhs -> c_rhs   (* rhs + rhs *)
  | C_Alloc : RType -> c_rhs -> c_rhs (* (r* ) malloc(rhs) *)
  .

Inductive c_cmd : Set :=
  | C_Skip : c_cmd                     (* skip *)
  | C_Seq : c_cmd -> c_cmd -> c_cmd    (* c1 ; c2 *)
  | C_Assign : c_lhs -> c_rhs -> c_cmd (* lhs = rhs *)
  | C_Call : c_rhs -> c_cmd            (* rhs() *)
  | C_Free : c_rhs -> c_cmd            (* free(rhs) *)
  .

Parameter funTable : c_rhs -> option (frame * c_cmd).

Axiom validFun : forall E (fid: Fun) fr c,
  funTable (C_Fun fid) = Some (fr, c) ->
  funAddress <= fid < minAddress /\
  validAddress E.(mem) fid.

(******************************************************************************)
(** *                 Well-formedness                                         *)
(******************************************************************************)
(**
  Our Coq proof defines a well-formedness predicate on syntax that
  picks out a subset of programs with these invariants. *)

(**
  [GlobalVar], [frame] |-lhs [c_lhs] : [AType] defines a well-formed
  left-hand-side that ensures that each variable in a left-hand-side [c_lhs]
  has an atomic type [AType] assigned by global variables [GlobalVar] or
  stack frames [frame].

  A global variable vid is with type a if it is not defined in the local stack
  frame, and global variables map vid into a well-formed type a.
<<
     fr(vid) = None
     G(vid) = (loc, a)
     |-a a
    -------------------- :: WF_GVar
     G, fr |-lhs vid: a
>>
  A local variable vid is with type a if it is defined in the stack frame with
  a well-formed type a.
<<
     fr(vid) = a
     |-a a
    -------------------- :: WF_SVar
     G, fr |-lhs vid: a
>>
  A pointer dereference *lhs is of type a if lhs is of type a*.
<<
     G, fr |-lhs lhs: a*
    --------------------- :: WF_Deref
     G, fr |-lhs *lhs: a
>>
  A field of an anonymous struct, lhs->id, is of type a if lhs is a
  pointer to an anonymous struct s, and s maps id to the type a.
<<
     G, fr |-lhs lhs: s*
     getStructType(s, id) = a
    -------------------------- :: WF_StructPos
     G, fr |-lhs lhs->id: a
>>
  A field of a named struct, lhs->id, is of type a if lhs is a
  pointer to a named struct n, [typeTable] maps n to an anonymous
  struct s, and s maps id to the type a.
<<
     G, fr |-lhs lhs: n*
     typeTable(n) = s
     getStructType(s, id) = a
    -------------------------- :: WF_NamePos
     G, fr |-lhs lhs->id: a
>>
*)

Inductive wf_lhs : GlobalVar -> frame -> c_lhs -> AType -> Prop :=
  | WF_GVar : forall G fr (vid: Var) (a: AType) (loc: Loc),
      fr vid = None ->
      lookUpGlobalVar G vid = Some (loc, a) ->
      wf_AType a ->
      wf_lhs G fr (C_Var vid) a
  | WF_SVar : forall G fr (vid: Var) (a: AType),
      fr vid = Some a ->
      wf_AType a ->
      wf_lhs G fr (C_Var vid) a
  | WF_Deref : forall G fr lhs a,
      wf_lhs G fr lhs (A_Pointer (R_AType a)) ->
      wf_lhs G fr (C_Deref lhs) a
  | WF_StructPos : forall G fr lhs id a s,
      wf_lhs G fr lhs (A_Pointer (R_Struct s)) ->
      getStructType s id = Some a ->
      wf_lhs G fr (C_StructPos lhs id) a
  | WF_NamePos : forall G fr lhs id a n s,
      wf_lhs G fr lhs (A_Pointer (R_Name n)) ->
      typeTable n = Some s ->
      getStructType s id = Some a ->
      wf_lhs G fr (C_NamePos lhs id) a
  .

(**
  [GlobalVar], [frame] |-rhs [c_rhs] : [AType] defines a well-formed
  right-hand-side that ensures that each value in a right-hand-side [c_rhs]
  has an atomic type [AType] assigned by global variables [GlobalVar] or
  stack frames [frame].

  First of all, integer constants are always of type int.
<<
    -------------------- :: WF_Const
     G, fr |-rhs n: int
>>
  The size of a well-formed referent type is also a well-formed right-hand-side.
<<
     |-r r
    ---------------------------- :: WF_Size
     G, fr |-rhs sizeof(r): int
>>
  A function name fid is of type ( * )().
<<
     funTable(fid) = (fr, c)
    ------------------------------- :: WF_Fun
     G, fr |-rhs fid: void ( * )()
>>
  If this right-hand-side is derived from a left-hand-side, it is well-formed
  when the left-hand-side is well-formed.
<<
     G, fr |-lhs lhs: a
    -------------------- :: WF_Lhs
     G, fr |-rhs lhs: a
>>
  An address of a left-hand-side, &lhs, is of type r* if r* is well-formed, and
  lhs is with any type a.
<<
     G, fr |-lhs lhs: a
     |-a a*
    ---------------------------- :: WF_Ref
     G, fr |-rhs (a* ) &lhs: a*
>>
  A cast, (a) rhs, is well-formed if both rhs and type a are well-formed.
<<
     G, fr |-rhs rhs: a'
     |-a a
    ------------------------ :: WF_Cast
     G, fr |-rhs (a) rhs: a
>>
  We consider two kinds of additions: integer additions and pointer arithmetics.
<<
     G, fr |-rhs rhs1: int
     G, fr |-rhs rhs2: int
    ------------------------------ :: WF_Add_Int_Int
     G, fr |-rhs rhs1 + rhs2: int

     G, fr |-rhs rhs1: r*
     |-a r*
     G, fr |-rhs rhs2: int
    ----------------------------- :: WF_Add_Ptr_Int
     G, fr |-rhs rhs1 + rhs2: r*
>>
  #<i>#malloc#</i># must allocate memory with positive size, and return a
  well-formed pointer type. The size to allocate, rhs, is also well-formed.
<<
     G, fr |-rhs rhs: int
     |-a r*
     sizeOfRtype(r) = size
     size > 0
    ----------------------------------- :: WF_Alloc
     G, fr |-rhs (r* ) malloc(rhs): r*
>>
*)

Inductive wf_rhs : GlobalVar -> frame -> c_rhs -> AType -> Prop :=
  | WF_Const : forall G fr n,
      wf_rhs G fr (C_Const n) A_Int
  | WF_Size : forall G fr r,
      wf_RType r ->
      wf_rhs G fr (C_Size r) A_Int
  | WF_Fun : forall G (fr: frame) fid fr c,
      funTable (C_Fun fid) = Some (fr, c) ->
      wf_rhs G fr (C_Fun fid) (A_Pointer R_Func)
  | WF_Lhs : forall G fr lhs a,
      wf_lhs G fr lhs a ->
      wf_rhs G fr (C_Lhs lhs) a
  | WF_Ref : forall G fr a lhs,
      wf_lhs G fr lhs a ->
      wf_AType (A_Pointer (R_AType a)) ->
      wf_rhs G fr (C_Ref a lhs) (A_Pointer (R_AType a))
  | WF_Cast : forall G fr a rhs a',
      wf_rhs G fr rhs a' ->
      wf_AType a ->
      wf_rhs G fr (C_Cast a rhs) a
  | WF_Add_Int_Int : forall G fr rhs1 rhs2,
      wf_rhs G fr rhs1 A_Int ->
      wf_rhs G fr rhs2 A_Int ->
      wf_rhs G fr (C_Add rhs1 rhs2) A_Int
  | WF_Add_Ptr_Int : forall G fr rhs1 rhs2 r,
      wf_rhs G fr rhs1 (A_Pointer r) ->
      wf_AType (A_Pointer r) ->
      wf_rhs G fr rhs2 A_Int ->
      wf_rhs G fr (C_Add rhs1 rhs2) (A_Pointer r)
  | WF_Alloc : forall G fr r rhs size,
      wf_rhs G fr rhs A_Int ->
      wf_AType (A_Pointer r) ->
      sizeOfRType r = Some size ->
      size > 0 ->
      wf_rhs G fr (C_Alloc r rhs) (A_Pointer r)
  .

(**
  [GlobalVar], [frame] |-c [c_cmd] defines a well-formed command
  with respect to global variables [GlobalVar] and stack frames [frame].

  Empty commands are trivially well-formed.
<<
    ---------------- :: Wf_Skip
     G, fr |-c skip
>>
  A sequence of commands is well-formed if each command is well-formed.
<<
     G, fr |-c c1
     G, fr |-c c2
    ------------------- :: Wf_Seq
     G, fr |-c c1 ; c2
>>
  Given an assignment, we check if the left-hand-side and the right-hand-side
  are well-formed.
<<
     G, fr |-lhs lhs: al
     G, fr |-rhs rhs: ar
    --------------------- :: WF_Assign
     G, fr |-c lhs = rhs
>>
  To check a function call, we ensure that the function address is a well-formed
  right-hand-side and the function has been stored in [funTable] with a local
  frame fr' and commands c', then check if c' is well-formed w.r.t G and fr'.
<<
     G, fr |-rhs rhs: a
     funTable(rhs) = (fr', c')
     G, fr' |-c c'
    --------------------------- :: WF_Call
     G, fr |-c rhs()
>>
  #<i>#free#</i># must deallocate a well-formed right-hand-side with pointer
  types.
<<
     G, fr |-rhs rhs: r*
    --------------------- :: WF_Free
     G, fr |-c free(rhs)
>>
*)

Inductive wf_cmd : GlobalVar -> frame -> c_cmd -> Prop :=
  | WF_Skip : forall G fr,
      wf_cmd G fr (C_Skip)
  | WF_Seq : forall G fr c1 c2,
      wf_cmd G fr c1 ->
      wf_cmd G fr c2 ->
      wf_cmd G fr (C_Seq c1 c2)
  | WF_Assign : forall G fr lhs rhs al ar,
      wf_lhs G fr lhs al ->
      wf_rhs G fr rhs ar ->
      wf_cmd G fr (C_Assign lhs rhs)
  | WF_Call : forall G fr rhs a fr' c',
      wf_rhs G fr rhs a ->
      funTable rhs = Some (fr', c') ->
      wf_cmd G fr' c' ->
      wf_cmd G fr (C_Call rhs)
  | WF_Free : forall G fr rhs r,
      wf_rhs G fr rhs (A_Pointer r) ->
      wf_cmd G fr (C_Free rhs)
  .

(* begin hide *)
Require Import String.
Open Scope string_scope.

Tactic Notation "wf_lhs_cases" tactic(first) tactic(c) :=
  first;
  [ c "WF_GVar" | c "WF_SVar" | c "WF_Deref" | c "WF_StructPos" | c "WF_NamePos" ].

Tactic Notation "wf_tame_ref_lhs_cases" tactic(first) tactic(c) :=
  first;
  [ c "WF_TR_GVar" | c "WF_TR_SVar" | c "WF_TR_StructPos" | c "WF_TR_NamePos" ].

Tactic Notation "wf_rhs_cases" tactic(first) tactic(c) :=
  first;
  [ c "WF_Const" | c "WF_Size" | c "WF_Fun" | c "WF_Lhs" | c "WF_Ref" |
    c "WF_Cast" | c "WF_Add_Int_Int" | c "WF_Add_Ptr_Int" | c "WF_Alloc" ].

Tactic Notation "wf_cmd_cases" tactic(first) tactic(c) :=
  first;
  [ c "WF_Skip" | c "WF_Seq" | c "WF_Assign" | c "WF_Call" | c "WF_Free" ].
(* end hide *)

Global Hint Constructors c_lhs c_rhs c_cmd : core.
Global Hint Resolve WF_Const WF_Size WF_Fun WF_Lhs WF_Ref
     WF_Cast WF_Add_Int_Int WF_Add_Ptr_Int WF_Skip WF_Seq : core.
